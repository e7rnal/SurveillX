# GStreamer + webrtcbin — Implementation Guide

## Step 1: Signaling Server (WebSocket)

GStreamer's `webrtcbin` exchanges SDP and ICE candidates via WebSocket. We need a lightweight signaling server.

See [server.py](./server.py) for the full reference implementation.

### Core concept:

```python
import asyncio
import websockets
import gi
gi.require_version('Gst', '1.0')
gi.require_version('GstWebRTC', '1.0')
from gi.repository import Gst, GstWebRTC, GstSdp

Gst.init(None)

# Build pipeline
pipe = Gst.parse_launch("""
    webrtcbin name=recv bundle-policy=max-bundle stun-server=stun://stun.l.google.com:19302
    recv. ! rtpvp8depay ! vp8dec ! videoconvert ! video/x-raw,format=BGR
    ! appsink name=sink emit-signals=true sync=false max-buffers=2 drop=true
""")

webrtcbin = pipe.get_by_name("recv")
appsink = pipe.get_by_name("sink")
```

## Step 2: Handle SDP Exchange

```python
async def handle_client(websocket):
    # Receive SDP offer from Windows client
    msg = await websocket.recv()
    offer = json.loads(msg)
    
    # Set remote description
    sdp = GstSdp.SDPMessage.new_from_text(offer["sdp"])[1]
    remote = GstWebRTC.WebRTCSessionDescription.new(
        GstWebRTC.WebRTCSDPType.OFFER, sdp
    )
    webrtcbin.emit("set-remote-description", remote, None)
    
    # Create answer
    promise = Gst.Promise.new()
    webrtcbin.emit("create-answer", None, promise)
    promise.wait()
    reply = promise.get_reply()
    answer = reply.get_value("answer")
    webrtcbin.emit("set-local-description", answer, None)
    
    # Send answer back
    await websocket.send(json.dumps({
        "type": "answer",
        "sdp": answer.sdp.as_text()
    }))
```

## Step 3: Handle ICE Candidates

```python
# Server → Client (generated by webrtcbin)
def on_ice_candidate(element, mlineindex, candidate):
    asyncio.run_coroutine_threadsafe(
        websocket.send(json.dumps({
            "type": "ice",
            "candidate": candidate,
            "sdpMLineIndex": mlineindex
        })),
        loop
    )

webrtcbin.connect("on-ice-candidate", on_ice_candidate)

# Client → Server (received via WebSocket)
async def receive_ice():
    async for msg in websocket:
        data = json.loads(msg)
        if data["type"] == "ice":
            webrtcbin.emit("add-ice-candidate", data["sdpMLineIndex"], data["candidate"])
```

## Step 4: Frame Callback (appsink)

This is where GStreamer hands off to Python for face recognition:

```python
import numpy as np
import cv2

def on_new_sample(sink):
    sample = sink.emit("pull-sample")
    buf = sample.get_buffer()
    caps = sample.get_caps()
    
    # Extract frame dimensions
    struct = caps.get_structure(0)
    width = struct.get_value("width")
    height = struct.get_value("height")
    
    # Map buffer to numpy
    success, map_info = buf.map(Gst.MapFlags.READ)
    if success:
        frame = np.ndarray(
            shape=(height, width, 3),
            dtype=np.uint8,
            buffer=map_info.data
        )
        
        # Face recognition
        process_for_attendance(frame)
        
        # Forward to browser
        forward_to_browser(frame)
        
        buf.unmap(map_info)
    
    return Gst.FlowReturn.OK

appsink.connect("new-sample", on_new_sample)
```

## Step 5: Forward to Browser (Same as FastRTC)

```python
import socketio
sio = socketio.Client()
sio.connect('http://localhost:5000', namespaces=['/stream'])

def forward_to_browser(frame):
    _, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 70])
    frame_b64 = base64.b64encode(buffer).decode('utf-8')
    sio.emit('frame', {
        'frame': frame_b64,
        'camera_id': 1,
        'timestamp': str(time.time())
    }, namespace='/stream')
```

## Step 6: Run the Server

```bash
# Terminal 1: Flask
python app.py  # port 5000

# Terminal 2: GStreamer streaming server
python gst_streaming_server.py  # WebSocket on port 8443
```

## Step 7: Windows Client

Two options:

### Option A: aiortc client (easier, same as FastRTC)
Use the same Python client from the FastRTC folder. Just change the signaling to WebSocket.

### Option B: GStreamer on Windows (fastest)
Install GStreamer for Windows and use `gst-launch` or the Python script in [client.py](./client.py).

## Step 8: Browser (No Changes!)

Same as FastRTC — the browser already listens for Socket.IO `frame` events. No changes needed.

## Troubleshooting

| Issue | Fix |
|-------|-----|
| `webrtcbin` not found | `sudo apt install gstreamer1.0-plugins-bad` |
| `gi` import error | `sudo apt install python3-gi gir1.2-gst-plugins-bad-1.0` |
| No ICE candidates | Check coturn, check firewall |
| Black frames | Check `videoconvert` element in pipeline, verify format=BGR |
| High CPU | Add `queue` elements between pipeline stages |

## Performance Tuning

```
# Low-latency pipeline with queue tuning:
webrtcbin name=recv bundle-policy=max-bundle
    recv. ! queue max-size-buffers=2 leaky=downstream
    ! rtpvp8depay ! vp8dec
    ! queue max-size-buffers=2 leaky=downstream
    ! videoconvert ! video/x-raw,format=BGR
    ! appsink name=sink emit-signals=true sync=false max-buffers=1 drop=true
```
